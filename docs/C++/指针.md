# C/C++ 指针

## 使用格式

`Type *name = value`

### 详细用法解析：

`name`自定义，作为指针变量指代指针。其值为指针的首个内存地址  
`*name` 指向指针变量 `name`。其值为指向内存地址中存储的值  
Type 决定了应该占用多大的内存  

## 使用 new 分配内存 

使用指针以使用动态数组 

使用`new`关键字可以在堆上分配内存，返回的是指向该内存的指针
似乎像 `vector<typename> VecName` 不能使用 new 分配内存
```cpp
 int nums[] = new nums
```

## 数组和指针

在C++中，函数参数声明为指针时（如 int* begin），我们声明的是一个变量 begin，它是一个指向整数 (int) 的指针。这里的 * 是类型的一部分，用来表示 begin 是一个指针类型，而不是说我们要将某个值赋给 *begin。

当你调用函数并传递参数时，例如 sum_arr(cookies, cookies + ArSize)，你传递的是实际的指针（即数组名 cookies 被自动转换为首元素的地址）。因此，在函数内部，begin 接收的是这个地址，而不是解引用后的值。

为了更清晰地理解这一点，我们可以考虑以下几点：

参数声明：当我们在函数定义中写 const int * begin 时，我们是在声明 begin 是一个指向常量整数的指针。这并不意味着我们将要直接操作 *begin；相反，它说明了我们将通过 begin 来间接访问数据。
参数传递：当我们调用 sum_arr(cookies, ...) 时，cookies 自动转换为指向其第一个元素的指针，并被赋值给 begin。这意味着 begin = &cookies[0] 或者简单地说 begin = cookies，因为数组名可以隐式转换为指向其第一个元素的指针。
标准的理解：根据 C++ 标准，当你传递一个数组给函数时，实际上是在传递一个指向数组第一个元素的指针。而指针本身是一个存储内存地址的变量，它可以被复制和传递。这就是为什么我们声明的是 begin 而不是 *begin，因为我们需要传递的是地址，而不是该地址所指向的值。
解引用操作：*begin 是对 begin 指针进行解引用的操作，它返回指针所指向位置的值。在函数内部，我们使用 *begin 来读取或修改指针指向的数据，但这是在函数内部的操作，与参数传递无关。
总结   
begin = cookies 是符合C++语言标准的行为，因为我们在传递的是指针，也就是地址，而不是指针所指向的值。声明的是 begin，因为它是我们用来接收传入地址的指针变量，而 *begin 只是我们在函数内部用来访问指针所指向的数据的方式。
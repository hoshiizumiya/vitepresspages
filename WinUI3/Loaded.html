<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++/WinRT 原理及实践 —— WinUI3 的页面加载事件解析、以WPF为源、C#/cppwinRT为例 | Hoshiizumiya</title>
    <meta name="description" content="learn notes">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/vitepresspages/assets/style.CN1xNsPh.css" as="style">
    <link rel="preload stylesheet" href="/vitepresspages/vp-icons.css" as="style">
    
    <script type="module" src="/vitepresspages/assets/app.CVRw5pHX.js"></script>
    <link rel="preload" href="/vitepresspages/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/vitepresspages/assets/chunks/theme.CsjXfZ_X.js">
    <link rel="modulepreload" href="/vitepresspages/assets/chunks/framework.eveauE4a.js">
    <link rel="modulepreload" href="/vitepresspages/assets/WinUI3_Loaded.md.bqVwbDvd.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/vitepresspages/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>Hoshiizumiya</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepresspages/index.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepresspages/README.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>About me</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/hoshiizumiya" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/hoshiizumiya" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>过时的项目指南</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/gitbook%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%85%A8%E6%8C%87%E5%8D%97/gitbook%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>gitbook本地部署</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>C++</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/C++/%E7%9B%AE%E5%BD%95.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>目录</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>字符串</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/C++/%E6%8C%87%E9%92%88.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>指针</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/C++/%E8%BF%9E%E7%BB%AD%E8%AF%BB%E5%8F%96.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>连续读取</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/C++/2.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>JAVA类数组和方法的重构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/C++/memory1.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>C++ 11 —— 移动语义</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>计算机图形学</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9B%AE%E5%BD%95.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>目录</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>WinUI3 C++/WinRT 原理及实践</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/index.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>目录</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/EP3.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>EP3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/TitleBar.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>cpp/WinRT入门-TitleBar标题栏</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/Loaded.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>cpp/WinRT入门-Loaded事件</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/Template.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>cpp/WinRT入门-模板元编程在 WinRT 中的实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E9%9B%B6%E9%83%A8%E5%88%86-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第零部分-环境配置与基础概念</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第一部分-基础概念与架构</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%AE%9E%E8%B7%B5%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第二部分-实践开发指南</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%BC%80%E5%8F%91.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第三部分-高级特性与深度开发</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80API%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第四部分-基础API与类型系统深度解析</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-XAML%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%B7%B1%E5%B1%82%E6%9C%BA%E5%88%B6.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第五部分-XAML框架与数据绑定深层机制</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/WinUI3-WinRT-CPP-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>系列教程-第六部分-实战技巧与最佳实践</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/vitepresspages/WinUI3/scale.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>DPI 缩放</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _vitepresspages_WinUI3_Loaded" data-v-39a288b8><div><h1 id="c-winrt-原理及实践-——-winui3-的页面加载事件解析、以wpf为源、c-cppwinrt为例" tabindex="-1">C++/WinRT 原理及实践 —— WinUI3 的页面加载事件解析、以WPF为源、C#/cppwinRT为例 <a class="header-anchor" href="#c-winrt-原理及实践-——-winui3-的页面加载事件解析、以wpf为源、c-cppwinrt为例" aria-label="Permalink to &quot;C++/WinRT 原理及实践 —— WinUI3 的页面加载事件解析、以WPF为源、C#/cppwinRT为例&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>如果你对 WPF 框架熟悉，那么在 WinUI 3 中，你同样可以直接对页面或控件注册 Loaded 事件，而且语法更清晰。你仍然需要 Loaded 事件来执行“页面加载完成后”的逻辑 —— 它没有被废弃，只是写法变了。本篇将以最详细的解释为你疏清相关知识。</p><p>本节涉及到的概念有：</p><ul><li>事件注册</li><li>事件处理</li><li>XAML 根元素语法</li><li>C++ 回调</li><li>C++/WinRT 语法</li><li>C++ 成员函数指针</li></ul><h2 id="回顾" tabindex="-1">回顾 <a class="header-anchor" href="#回顾" aria-label="Permalink to &quot;回顾&quot;">​</a></h2><p>让我们先看看大多数熟悉的 WPF 为了实现页面加载后的逻辑是如何实现的。 我们使用的是事件注册语法：</p><h3 id="两种标准的-wpf-c-xaml-中的-loaded-事件写法" tabindex="-1">两种标准的 WPF（C#/XAML）中的 Loaded 事件写法 <a class="header-anchor" href="#两种标准的-wpf-c-xaml-中的-loaded-事件写法" aria-label="Permalink to &quot;两种标准的 WPF（C#/XAML）中的 Loaded 事件写法&quot;">​</a></h3><h4 id="在-wpf-里-你可以直接在-xaml-页面的根元素-如-window-或-page-类型-上写-这就可以了-相当于在-xaml-页面里注册了" tabindex="-1">在 WPF 里，你可以直接在 XAML 页面的根元素（如 Window 或 Page 类型）上写，这就可以了，相当于在 xaml 页面里注册了： <a class="header-anchor" href="#在-wpf-里-你可以直接在-xaml-页面的根元素-如-window-或-page-类型-上写-这就可以了-相当于在-xaml-页面里注册了" aria-label="Permalink to &quot;在 WPF 里，你可以直接在 XAML 页面的根元素（如 Window 或 Page 类型）上写，这就可以了，相当于在 xaml 页面里注册了：&quot;">​</a></h4><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Mainwindow.xaml</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> x:Class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Demo.MainWindow&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Window_Loaded&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; 这里需要你自定义</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 你的页面内容 Your page content --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>然后在 C# 代码里直接补充实现自动生成的事件处理函数：</p><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MainWindow.xaml.cs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window_Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 页面加载完成后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="我们同样还有另外的方法——也经常使用事件订阅语法-用来简便的注册和使用" tabindex="-1">我们同样还有另外的方法——也经常使用<strong>事件订阅</strong>语法 用来简便的注册和使用： <a class="header-anchor" href="#我们同样还有另外的方法——也经常使用事件订阅语法-用来简便的注册和使用" aria-label="Permalink to &quot;我们同样还有另外的方法——也经常使用**事件订阅**语法 用来简便的注册和使用：&quot;">​</a></h4><p>我们在对应的窗口类的构造函数里，用 cs 独有的<code>+=</code>（事件注册操作符）来添加事件处理程序，这也是标准的写法！当然你大可不遵守。 意思是把这个方法添加到这个事件的监听列表中。表示：当 Loaded 事件发生时，调用后面的方法。</p><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MainWindow.xaml.cs 的构造函数或其他初始化方法中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    InitializeComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用 += 简便地注册事件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //将 Window_Loaded 方法注册为 Loaded 事件的处理程序。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Window_Loaded;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 和前面所写的一致</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window_Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 页面加载完成后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="当然还有更简便的使用匿名方法-没有函数名字的方法-、-以-lambda-表达式注册" tabindex="-1">当然还有更简便的使用匿名方法（没有函数名字的方法）、 以 lambda 表达式注册： <a class="header-anchor" href="#当然还有更简便的使用匿名方法-没有函数名字的方法-、-以-lambda-表达式注册" aria-label="Permalink to &quot;当然还有更简便的使用匿名方法（没有函数名字的方法）、 以 lambda 表达式注册：&quot;">​</a></h4><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 直接写加载完成后的逻辑，适用于简单的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MessageBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;窗口已加载！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>我们也再仔细回顾一下这个 C# 语法方便初学者理解：</p><ul><li>()内代表要传给后面方法的参数列表。在这里事件处理函数的两个参数：</li><li>sender：表示是哪个对象触发了这个事件（比如是哪个窗口）。</li><li>e：是事件的参数，包含事件相关的额外信息（比如鼠标点击位置、键盘按键等）。</li><li>参数的具体类型是编译器自动推断</li></ul><h4 id="到底是什么" tabindex="-1">=&gt; 到底是什么？ <a class="header-anchor" href="#到底是什么" aria-label="Permalink to &quot;=&gt; 到底是什么？&quot;">​</a></h4><ul><li>符号读作 “goes to” 或 “yields to”。</li><li>它的作用是：把左边的参数，连接到右边的代码块或表达式。</li><li>类似于说：“用 (sender, e) 作为输入，执行 =&gt; 后面的大括号里的代码”。</li></ul><p>说的很详细了，不再过多解释。</p><h2 id="在-winui3-里什么发生了变化" tabindex="-1">在 WinUI3 里什么发生了变化 <a class="header-anchor" href="#在-winui3-里什么发生了变化" aria-label="Permalink to &quot;在 WinUI3 里什么发生了变化&quot;">​</a></h2><p>在 WinUI 3 C++/WinRT 框架中，Loaded 事件是 FrameworkElement 的成员。<br> 在 WPF（.NET 框架，C#/XAML）中，Window 和 Page 都继承自 FrameworkElement，而 FrameworkElement 有 Loaded 事件。所以你可以直接在 XAML 根元素这样写： 在 WinUI 3（无论 C# 还是 C++/WinRT），Window 和 Page 的继承体系发生了变化：（这点很坑）</p><ul><li>Window 类不再继承自 FrameworkElement，而是直接继承自 IInspectable。</li><li>Window 类里没有 Loaded 事件。</li><li>Page 在 WinUI 3 里虽然继承自 FrameworkElement，但有些事件的实现和 WPF 不完全一致。</li></ul><p>而只有属于 FrameworkElement 及其子类（如 Grid、StackPanel、Button 等）才有 Loaded 事件。你直接从主窗口使用该函数是会报错类中没有此成员函数的。</p><p>更清晰地来说，在 WinUI 3 的类型层次结构中，Window 直接继承自 IInspectable 属于 <a href="https://learn.microsoft.com/zh-cn/uwp/api/windows.ui.xaml.window?view=winrt-26100" target="_blank" rel="noreferrer">Microsoft.UI.Xaml</a> 命名空间，但它没有 Loaded 事件。FrameworkElement 则直接继承自 <a href="https://learn.microsoft.com/zh-cn/uwp/api/windows.ui.xaml.uielement?view=winrt-26100" target="_blank" rel="noreferrer">UIElement</a>。</p><h3 id="winui-3-中的-loaded-事件写法" tabindex="-1">WinUI 3 中的 Loaded 事件写法 <a class="header-anchor" href="#winui-3-中的-loaded-事件写法" aria-label="Permalink to &quot;WinUI 3 中的 Loaded 事件写法&quot;">​</a></h3><p>在 WinUI 3 里，Window 没有 Loaded 事件，Page 有，但仍然具有偶发的兼容性问题。具体来说在复杂的导航场景下，有些内容可能会被重新加载，导致 Loaded 事件可能会触发多次。生命周期和异步加载都有可能会影响 Loaded 事件的触发。所以需要仔细地控制页面的加载逻辑。</p><p>推荐在 xaml 页面的某个控件（如 LayoutGrid）上绑定 Loaded 事件：</p><div class="language-XML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">XML</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MainWindow.xaml</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    x:Class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Demo.MainWindow&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    xmlns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    xmlns:x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Grid</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;RootGrid_Loaded&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        &lt;!-- ... --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>C# 的 cs 页面代码同上，不再展出。</li><li>重点讲 C++/WinRT</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MainWindow.xaml.cpp</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RootGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::OnRootGridLoaded });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnRootGridLoaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Windows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Foundation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInspectable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Xaml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 页面加载完成后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="cpp-winrt-语法讲解" tabindex="-1">cpp/winrt 语法讲解： <a class="header-anchor" href="#cpp-winrt-语法讲解" aria-label="Permalink to &quot;cpp/winrt 语法讲解：&quot;">​</a></h3><h5 id="_1-rootgrid" tabindex="-1">1.<code>RootGrid()</code> <a class="header-anchor" href="#_1-rootgrid" aria-label="Permalink to &quot;1.`RootGrid()`&quot;">​</a></h5><ul><li>这是 <code>C++/WinRT</code> 自动生成的<strong>属性访问器</strong>函数。</li><li>在 XAML 里 <code>&lt;Grid x:Name=&quot;RootGrid&quot;/&gt;</code>，编译后会自动生成一个名为 RootGrid() 的成员函数，返回这个控件对应 x:Name 的实例。</li><li>用法类似 C# 的 RootGrid 属性，但 C++/WinRT 里是函数调用（带括号）。</li></ul><h5 id="_2-loaded" tabindex="-1">2.<code>.Loaded(...)</code> <a class="header-anchor" href="#_2-loaded" aria-label="Permalink to &quot;2.`.Loaded(...)`&quot;">​</a></h5><ul><li>Loaded 是 FrameworkElement 的一个事件，表示控件已经加载到可视树。</li><li>这里的 .Loaded(...) 是给这个事件注册一个处理函数（事件监听器）。</li></ul><h5 id="_3-this-mainwindow-onrootgridloaded" tabindex="-1">3.<code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> <a class="header-anchor" href="#_3-this-mainwindow-onrootgridloaded" aria-label="Permalink to &quot;3.`{ this, &amp;MainWindow::OnRootGridLoaded }`&quot;">​</a></h5><ul><li>这是 C++/WinRT <strong>事件注册</strong>的标准写法，叫“<strong>委托</strong>”或“<strong>事件回调</strong>”。 <code>{ this, &amp;MainWindow::OnRootGridLoaded } </code>表示用当前对象（<code>this</code>）的成员函数 <code>OnRootGridLoaded()</code> 作为事件处理器。</li><li>看到&amp;别急着认为是引用类型，这里是个大学问！ <ul><li>此处代表了取地址动作，那学过cpp的都知道函数名字不就相当于地址（见 C++ primer plus 7.10.1节 P199），话说再取地址是什么了。NONONO。</li><li>对于非成员的函数（也就是不属于任何类的），函数名确实可以在很多情况下隐式转换为函数指针，此处不再举例。</li><li>对于成员函数来说，不用害怕，略有不同： <ul><li>当你处理的是类的成员函数时，情况变得更加复杂。因为成员函数的第一个<strong>隐含参数</strong>是<code>this</code>指针。这意味着成员函数指针不仅仅是简单的函数地址，它还需要知道它属于哪个对象实例。</li><li>当你写<code>&amp;MainWindow::OnRootGridLoaded</code>时，你实际上是显式地在获取该成员函数的指针，这个指针包含了如何调用该成员函数的信息（包括如何找到正确的对象实例）。因此，在这种情况下，使用&amp;是必要的语法要求，以明确表达你正在获取成员函数的地址。</li><li>实际上，你可以选择省略这个<code>&amp;</code>。如果你不加<code>&amp;</code>，MSVC 编译器也会自动推导出。 C++ 允许<strong>在需要函数指针的地方</strong>，<strong>隐式</strong>地将成员函数名转换为函数指针。但是为了可读性和避免使用模板时可能造成的错误，最好记得加上。</li><li>我们再回忆成员函数概念，以解释清楚。作为成员函数，那么必须要绑定到一个具体的对象上才能被调用</li><li>那函数名究竟是什么：func 的名字相当于一个特殊的左值（Ivalue），代表函数本身，但它不是指针类型。函数名会“隐式转换”为函数指针当编译器看到你把函数名用在需要函数指针的地方，它会自动帮你加上 <code>&amp;</code>。即：<strong>函数到函数指针的隐式转换</strong>（function-to-pointer conversion）。</li><li>所以，如果你随意一个地方直接写 <code>MainWindow::OnRootGridLoaded</code> 其实是不行的，因为它本身不是一个左值，而是一个名字或者说成员函数标识符。必须用 <code>&amp;</code> 显式获取它的“成员函数指针”。那为什么我们在这里可以省略，因为因为 <code>C++/WinRT</code> 的 <code>Loaded</code> 事件接受的是一个<strong>可调用对象</strong>（Callable）。当编译器看到 MainWindow::OnRootGridLoaded 被用在需要“函数指针”的上下文中，于是自动把它加上了<code>&amp;</code>。多亏隐式转换！</li></ul></li></ul></li><li>这种写法本质上是把<strong>成员函数指针</strong>和<strong>对象指针</strong>一起传递，<code>C++/WinRT</code> 框架会自动帮你在事件发生时调用这个成员函数。</li></ul><h4 id="事件注册语法" tabindex="-1">事件注册语法！ <a class="header-anchor" href="#事件注册语法" aria-label="Permalink to &quot;事件注册语法！&quot;">​</a></h4><ul><li>我们用花括号{}来注册事件，写在参数列表的<code>{}</code>里。</li><li><code>C++/WinRT</code> 事件注册需要一个“<strong>委托对象</strong>”，即谁来处理事件、用哪个成员函数。</li><li><code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> 是 <code>C++/WinRT</code> 的语法糖，等价于 C# 的 += 事件注册。</li><li>这样写可以让框架知道：当事件发生时，调用 this（当前窗口对象）的 <code>OnRootGridLoaded</code> 成员函数。</li></ul><h4 id="相信你看完还是一头雾水-这贵物东西究竟是个啥啊" tabindex="-1">相信你看完还是一头雾水！这贵物东西究竟是个啥啊！ <a class="header-anchor" href="#相信你看完还是一头雾水-这贵物东西究竟是个啥啊" aria-label="Permalink to &quot;相信你看完还是一头雾水！这贵物东西究竟是个啥啊！&quot;">​</a></h4><p><code>C++/WinRT</code> <strong>事件监听器</strong>（比如 Loaded）为什么在参数列表里要用大括号 { this, &amp;MainWindow::OnRootGridLoaded }，而不是像 C# 那样直接写方法名或者用 +=？</p><p>再展开来讲，里面有关的众多绕耳名词，我们再来整理整理：</p><ul><li><p>记住<code>.Loaded()</code>就属于<strong>事件监听器</strong>，（）内就是 <strong>事件注册</strong> 函数，使用<strong>注册监听器</strong>语法，同时也是一个<strong>事件</strong>，需要传递一个<strong>委托对象</strong>（delegate）。不要纠结它的各种名字，越记越混。记住它不是一个简单的函数。</p></li><li><p>{}这种写法叫委托构造，会自动生成一个事件处理对象 也就是用来处理这个事件的对象。</p></li><li><p>既然是对象，它就保存了两个信息：</p><ul><li>this：当前类的实例指针（告诉框架事件发生时要调用哪个对象的方法）</li><li>&amp;MainWindow::OnRootGridLoaded：成员函数指针（告诉框架具体调用哪个成员函数）</li></ul></li><li><p>作用：在这个事件函数发生时（也就是该绑定的界面元素被加载完成后）执行注册的函数，winRT会在此时帮你自动调用（依赖消息循环）</p></li><li><p>你写他.Loaded()，就是调用Loaded事件的<code>add</code>方法，将你的<code>回调</code>注册进去，这个回调是什么意思——</p></li><li><p>虽然我们不能直接写一个函数/函数名在里面，但是我们也还可以用 lambda 表达式类似 cs 的注册方式。</p><ul><li>它也支持 lambda 类型语法直接注册事件：</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   RootGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([](</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这里写要执行的内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>但是呢，我们使用 <code>{ this, &amp;MainWindow::OnRootGridLoaded }</code>是最常见和推荐的注册方式！</li></ul></li></ul><h2 id="回调" tabindex="-1">回调 <a class="header-anchor" href="#回调" aria-label="Permalink to &quot;回调&quot;">​</a></h2><h4 id="我们刚才不停地提到了事件回调-回调在-cpp-里是一个很有深度的概念" tabindex="-1">我们刚才不停地提到了事件回调，回调在 cpp 里是一个很有深度的概念： <a class="header-anchor" href="#我们刚才不停地提到了事件回调-回调在-cpp-里是一个很有深度的概念" aria-label="Permalink to &quot;我们刚才不停地提到了事件回调，回调在 cpp 里是一个很有深度的概念：&quot;">​</a></h4><p>其实我们一直在讲的就是<strong>事件回调</strong>（Event Callback）的典型用法（统称<strong>回调</strong>）。 回调 = 把函数作为事件注册出去，等事件发生时系统自动调用它。</p><p><code>{ this, &amp;MainWindow::OnRootGridLoaded }</code>这就是在注册一个回调函数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>    你写的代码：</span></span>
<span class="line"><span>    RootGrid().Loaded({ this, &amp;MainWindow::OnRootGridLoaded });</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    你告诉 XAML 系统：</span></span>
<span class="line"><span>    “当 RootGrid 加载完成时，请调用 MainWindow 的 OnRootGridLoaded 函数”</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    XAML 系统记住了这个“请求”（注册了回调）</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    运行时：RootGrid 真的加载完成了！</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    系统回头调用你提供的函数：</span></span>
<span class="line"><span>    this-&gt;OnRootGridLoaded(sender, e);</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    你的代码执行：</span></span>
<span class="line"><span>    // 页面加载完成后的逻辑</span></span></code></pre></div><h5 id="这里也有一些-c-winrt-中的语法细节" tabindex="-1">这里也有一些 C++/WinRT 中的语法细节 <a class="header-anchor" href="#这里也有一些-c-winrt-中的语法细节" aria-label="Permalink to &quot;这里也有一些 C++/WinRT 中的语法细节&quot;">​</a></h5><p><code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> 是 <code>C++/WinRT</code> 的 事件处理程序语法，它等价于“绑定一个成员函数作为事件处理器”。底层使用了 <code>winrt::auto_revoke</code> 和<strong>委托</strong>（delegate）机制，确保对象销毁时自动取消注册，防止崩溃。我们可能以后会继续来解析。 值得一提的是这种方法非常利好于性能，因为回调的核心是在于提前告诉框架在哪一步要做什么。我们就不需要时时刻刻循环监听页面的变化进行处理，到达了我们已经设定的目标状态，winRT 就会来调用。 因为系统在事件发生时“回头调用”它 → 所以叫“回调”。</p><h4 id="事件处理函数" tabindex="-1">事件处理函数 <a class="header-anchor" href="#事件处理函数" aria-label="Permalink to &quot;事件处理函数&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnRootGridLoaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Windows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Foundation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInspectable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Xaml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h5 id="winrt-windows-foundation-iinspectable-const-sender" tabindex="-1"><code>winrt::Windows::Foundation::IInspectable const&amp; sender</code> <a class="header-anchor" href="#winrt-windows-foundation-iinspectable-const-sender" aria-label="Permalink to &quot;`winrt::Windows::Foundation::IInspectable const&amp; sender`&quot;">​</a></h5><ul><li>sender：事件的发送者，即哪个控件触发了这个事件。</li><li>类型是 <code>IInspectable</code> <a href="https://learn.microsoft.com/en-us/windows/win32/api/inspectable/nn-inspectable-iinspectable" target="_blank" rel="noreferrer">MSLearn链接</a> <a href="./.html">讲解链接施工中</a>，这是 WinRT 所有对象的基类，类似 C# 里的 object。</li><li>你还可以使常用的 sender.as&lt;<code>Grid</code>&gt;() 之类的方法把它转换成具体控件类型，当然也可以不转换。 <ul><li><code>sender</code>：事件的发送者，基类型为 <code>IInspectable</code>。</li><li>.as&lt;<code>T</code>&gt;()：将 sender 转换为你需要的具体类型 T（如 Grid、Button 等）。</li><li>返回值是 T 目标类型的智能指针对象（如 winrt::Grid），可以直接访问控件的属性和方法。</li><li>在 C++/WinRT 中，事件处理函数的 sender 参数类型通常是 <code>winrt::Windows::Foundation::IInspectable</code>，这是 WinRT 所有对象的基类。</li><li>但实际触发事件的控件类型可能更具体，比如 Grid、Button 等。为了方便获取具体类型的对象，C++/WinRT 提供了 as&lt;<code>T</code>&gt;() 方法进行类型转换。</li><li>例如，你可以使用 sender.as&lt;<code>winrt::Microsoft::UI::Xaml::Controls::Grid</code>&gt;() 将 sender 转换为 Grid 类型，这样就可以访问 Grid 的特定属性和方法了。</li><li>注意事项： <ul><li>我们不要使用 <code>dynamic_cast</code> 或 <code>static_cast</code> 来转换 sender，因为 WinRT 使用了自己的类型系统和智能指针，其次它只适用于原生指针或引用也不支持这些 C++ 的 RTTI （运行时类型识别）特性，性能开销也很大。</li><li>sender 的类型是 <code>IInspectable</code>，它是 WinRT 所有对象的基类。本身不包含具体控件的属性和方法，你就访问不到。</li><li>如果 sender 实际不是你转换的类型，as&lt;<code>T</code>&gt;() 会抛出异常（<code>winrt::hresult_no_interface</code>）。</li><li>通常只有在你确定 sender 的实际类型时才使用 as&lt;<code>T</code>&gt;()。</li><li>这种写法类似于 C# 的 as 操作符，但 C++/WinRT 的 as&lt;<code>T</code>&gt;() 是强制转换，失败会抛异常。</li><li>你可以使用 try-catch 块来捕获异常，确保转换安全。但不能用模板函数来实现，因为 C++/WinRT 的 as&lt;<code>T</code>&gt;() 是编译时确定的类型转换且类型是确定的，当然你可以把它封装成一个函数来稍微简化使用。</li><li>底层调用 QueryInterface，只有在 sender 真正支持该类型时才会成功。</li></ul></li></ul></li></ul><h5 id="winrt-microsoft-ui-xaml-routedeventargs-const-e" tabindex="-1"><code>winrt::Microsoft::UI::Xaml::RoutedEventArgs const&amp; e</code> <a class="header-anchor" href="#winrt-microsoft-ui-xaml-routedeventargs-const-e" aria-label="Permalink to &quot;`winrt::Microsoft::UI::Xaml::RoutedEventArgs const&amp; e`&quot;">​</a></h5><ul><li>e：事件参数，包含事件相关的额外信息。</li><li>类型是 RoutedEventArgs，和 WPF 里的类似，表示“路由事件”的参数。</li><li>这里的命名空间是 Microsoft::UI::Xaml，因为 WinUI 3 的控件和事件都在这个命名空间下。</li></ul><h4 id="那问题来了-为什么有-windows-和-microsoft-两个命名空间" tabindex="-1">那问题来了：为什么有 Windows 和 Microsoft 两个命名空间？ <a class="header-anchor" href="#那问题来了-为什么有-windows-和-microsoft-两个命名空间" aria-label="Permalink to &quot;那问题来了：为什么有 Windows 和 Microsoft 两个命名空间？&quot;">​</a></h4><ul><li><p><code>winrt::Windows::Foundation::IInspectable：</code></p><ul><li>Windows::Foundation 是 WinRT 的基础命名空间，所有 WinRT 对象都继承自 IInspectable。</li><li>这是 WinRT 类型系统的根基，类似于 C# 的 object 或 C++ 的 void*，但有类型信息。</li></ul></li><li><p><code>winrt::Microsoft::UI::Xaml::RoutedEventArgs：</code></p><ul><li>Microsoft::UI::Xaml 是 WinUI 3 的控件和事件相关命名空间。</li><li>RoutedEventArgs 是所有路由事件的参数基类，包含事件路由相关信息。</li></ul></li></ul><h2 id="使用及用例" tabindex="-1">使用及用例 <a class="header-anchor" href="#使用及用例" aria-label="Permalink to &quot;使用及用例&quot;">​</a></h2><p>核心：手动在 XAML 里绑定 Loaded 事件，以及绑定必须要监听你的界面控件，属于在界面控件的代码。因为直接在界面根元素上绑定是没有的，会报错。</p><h3 id="什么时候-为什么要用-loaded-事件" tabindex="-1">什么时候，为什么要用 Loaded 事件？ <a class="header-anchor" href="#什么时候-为什么要用-loaded-事件" aria-label="Permalink to &quot;什么时候，为什么要用 Loaded 事件？&quot;">​</a></h3><p>Loaded 事件的典型应用场景包括：</p><ul><li><strong>初始化依赖于可视树的逻辑</strong>：有些操作（如获取控件的实际大小、布局信息、父子关系等）只有在控件真正加载到可视树后才能进行。</li><li><strong>动态数据绑定或界面刷新</strong>：在 Loaded 事件中加载数据、刷新界面，确保控件已准备好显示内容。</li><li><strong>动画、特效启动</strong>：页面或控件加载完成后启动动画，避免动画在控件未显示时提前执行。</li><li><strong>与外部资源交互</strong>：如页面加载后请求网络数据、初始化硬件资源等。</li><li><strong>只需执行一次的初始化逻辑</strong>：Loaded 事件只会在控件第一次加载到可视树时触发一次，适合做一次性的初始化。</li></ul><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li><strong>不要在 Loaded 事件中做耗时操作</strong>，否则会阻塞 UI 线程，导致界面卡顿。耗时操作应放到后台线程。</li><li><strong>Loaded 只触发一次</strong>，如果控件被移除再重新添加到可视树，会再次触发。</li><li><strong>Window 没有 Loaded 事件</strong>，只能在 Page 或 FrameworkElement（如 Grid、Panel、Button 等）上使用。</li></ul><h4 id="示例总结" tabindex="-1">示例总结 <a class="header-anchor" href="#示例总结" aria-label="Permalink to &quot;示例总结&quot;">​</a></h4><ul><li>WPF（C#）：Window/Page/控件都可以直接用 Loaded 事件。</li><li>WinUI 3（C#）：Page/控件可以用 Loaded，Window 不行。</li><li>WinUI 3（C++/WinRT）：只能在 FrameworkElement 及其子类控件上注册 Loaded 事件，推荐在主布局 Grid 上注册。</li></ul><h4 id="推荐实践" tabindex="-1">推荐实践 <a class="header-anchor" href="#推荐实践" aria-label="Permalink to &quot;推荐实践&quot;">​</a></h4><ul><li>在 XAML 主布局控件（如 <code>&lt;Grid x:Name=&quot;RootGrid&quot; Loaded=&quot;RootGrid_Loaded&quot;&gt;</code>）上注册相关 Loaded 事件。</li><li>在 C++/WinRT 代码中用 <code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> 注册事件处理器。</li><li>只在 Loaded 事件中做与 UI 相关的初始化，避免阻塞 UI。</li></ul><p>下一章我们准备讲解 InitializeComponent 函数的原理和实现，敬请期待。</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/vitepresspages/WinUI3/TitleBar.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>cpp/WinRT入门-TitleBar标题栏</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/vitepresspages/WinUI3/Template.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>cpp/WinRT入门-模板元编程在 WinRT 中的实现</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"c___2.md\":\"DjMgGOCl\",\"c___memory1.md\":\"DC8G47Ns\",\"c___字符串.md\":\"Cgmq0Agb\",\"c___指针.md\":\"DmKyeohb\",\"c___目录.md\":\"DJ0IQXfm\",\"c___连续读取.md\":\"CkeBabpD\",\"friends.md\":\"DBcuyvVO\",\"gitbook本地部署全指南_gitbook部署简介.md\":\"DEwZ2v0L\",\"gitbook本地部署全指南_step1-环境准备.md\":\"6xDU7H1e\",\"gitbook本地部署全指南_step2-gitbook.md\":\"pg9czuZV\",\"gitbook本地部署全指南_step3-gitbook进阶.md\":\"Dce-J8e7\",\"index.md\":\"-b14q6Pw\",\"markdown-examples.md\":\"DAKMSRv2\",\"readme.md\":\"w011D00n\",\"windows_index.md\":\"DLB0q3M0\",\"windows_windows内核.md\":\"PaCzluSe\",\"winui3_ep3.md\":\"CRISNe9u\",\"winui3_index.md\":\"CDWmLQex\",\"winui3_loaded.md\":\"bqVwbDvd\",\"winui3_scale.md\":\"CCKU9COl\",\"winui3_swapchainpanel.md\":\"ByC4VwMp\",\"winui3_template.md\":\"D2eC_Q7u\",\"winui3_titlebar.md\":\"COAkMMRI\",\"winui3_winui3-winrt-cpp-完整教程-第一部分-基础概念与架构.md\":\"DdYoh6ef\",\"winui3_winui3-winrt-cpp-完整教程-第三部分-高级特性与深度开发.md\":\"fk0zhuzI\",\"winui3_winui3-winrt-cpp-完整教程-第二部分-实践开发指南.md\":\"Cxj_kOYU\",\"winui3_winui3-winrt-cpp-完整教程-第五部分-xaml框架与数据绑定深层机制.md\":\"D4h55b-H\",\"winui3_winui3-winrt-cpp-完整教程-第六部分-实战技巧与最佳实践.md\":\"yZExZe3k\",\"winui3_winui3-winrt-cpp-完整教程-第四部分-基础api与类型系统深度解析.md\":\"Iq7tgIs9\",\"winui3_winui3-winrt-cpp-完整教程-第零部分-环境配置与基础概念.md\":\"eA-Gj6Gn\",\"计算机图形学_目录.md\":\"9xfedz6b\",\"计算机网络_5g.md\":\"Ce3ctpUg\",\"计算机网络_bt.md\":\"CarG1Qna\",\"计算机网络_index.md\":\"tokUhwfa\",\"计算机网络_tcpip协议开销.md\":\"BCQkttL5\",\"计算机网络_系统代理.md\":\"BrfS_L_S\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Hoshiizumiya\",\"description\":\"learn notes\",\"base\":\"/vitepresspages/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/index.md\"},{\"text\":\"About me\",\"link\":\"/README.md\"}],\"sidebar\":[{\"text\":\"过时的项目指南\",\"items\":[{\"text\":\"gitbook本地部署\",\"link\":\"/gitbook本地部署全指南/gitbook部署简介\"}]},{\"text\":\"C++\",\"items\":[{\"text\":\"目录\",\"link\":\"/C++/目录\"},{\"text\":\"字符串\",\"link\":\"/C++/字符串\"},{\"text\":\"指针\",\"link\":\"/C++/指针\"},{\"text\":\"连续读取\",\"link\":\"/C++/连续读取\"},{\"text\":\"JAVA类数组和方法的重构\",\"link\":\"/C++/2\"},{\"text\":\"C++ 11 —— 移动语义\",\"link\":\"/C++/memory1\"}]},{\"text\":\"计算机图形学\",\"items\":[{\"text\":\"目录\",\"link\":\"/计算机图形学/目录.md\"}]},{\"text\":\"WinUI3 C++/WinRT 原理及实践\",\"items\":[{\"text\":\"目录\",\"link\":\"/WinUI3/index.md\"},{\"text\":\"EP3\",\"link\":\"/WinUI3/EP3.md\"},{\"text\":\"cpp/WinRT入门-TitleBar标题栏\",\"link\":\"/WinUI3/TitleBar.md\"},{\"text\":\"cpp/WinRT入门-Loaded事件\",\"link\":\"/WinUI3/Loaded.md\"},{\"text\":\"cpp/WinRT入门-模板元编程在 WinRT 中的实现\",\"link\":\"/WinUI3/Template.md\"},{\"text\":\"系列教程-第零部分-环境配置与基础概念\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第零部分-环境配置与基础概念.md\"},{\"text\":\"系列教程-第一部分-基础概念与架构\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第一部分-基础概念与架构.md\"},{\"text\":\"系列教程-第二部分-实践开发指南\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第二部分-实践开发指南.md\"},{\"text\":\"系列教程-第三部分-高级特性与深度开发\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第三部分-高级特性与深度开发.md\"},{\"text\":\"系列教程-第四部分-基础API与类型系统深度解析\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第四部分-基础API与类型系统深度解析.md\"},{\"text\":\"系列教程-第五部分-XAML框架与数据绑定深层机制\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第五部分-XAML框架与数据绑定深层机制.md\"},{\"text\":\"系列教程-第六部分-实战技巧与最佳实践\",\"link\":\"/WinUI3/WinUI3-WinRT-CPP-完整教程-第六部分-实战技巧与最佳实践.md\"},{\"text\":\"DPI 缩放\",\"link\":\"/WinUI3/scale.md\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/hoshiizumiya\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>
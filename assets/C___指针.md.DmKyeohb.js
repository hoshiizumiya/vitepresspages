import{_ as a,c as i,o as n,ae as s}from"./chunks/framework.eveauE4a.js";const b=JSON.parse('{"title":"C/C++ 指针","description":"","frontmatter":{},"headers":[],"relativePath":"C++/指针.md","filePath":"C++/指针.md"}'),t={name:"C++/指针.md"};function o(c,e,r,p,d,l){return n(),i("div",null,e[0]||(e[0]=[s('<h1 id="c-c-指针" tabindex="-1">C/C++ 指针 <a class="header-anchor" href="#c-c-指针" aria-label="Permalink to &quot;C/C++ 指针&quot;">​</a></h1><h2 id="使用格式" tabindex="-1">使用格式 <a class="header-anchor" href="#使用格式" aria-label="Permalink to &quot;使用格式&quot;">​</a></h2><p><code>Type *name = value</code></p><h3 id="详细用法解析" tabindex="-1">详细用法解析： <a class="header-anchor" href="#详细用法解析" aria-label="Permalink to &quot;详细用法解析：&quot;">​</a></h3><p><code>name</code>自定义，作为指针变量指代指针。其值为指针的首个内存地址<br><code>*name</code> 指向指针变量 <code>name</code>。其值为指向内存地址中存储的值<br> Type 决定了应该占用多大的内存</p><h2 id="使用-new-分配内存" tabindex="-1">使用 new 分配内存 <a class="header-anchor" href="#使用-new-分配内存" aria-label="Permalink to &quot;使用 new 分配内存&quot;">​</a></h2><p>使用指针以使用动态数组</p><p>使用<code>new</code>关键字可以在堆上分配内存，返回的是指向该内存的指针 似乎像 <code>vector&lt;typename&gt; VecName</code> 不能使用 new 分配内存</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span></code></pre></div><h2 id="数组和指针" tabindex="-1">数组和指针 <a class="header-anchor" href="#数组和指针" aria-label="Permalink to &quot;数组和指针&quot;">​</a></h2><p>在C++中，函数参数声明为指针时（如 int* begin），我们声明的是一个变量 begin，它是一个指向整数 (int) 的指针。这里的 * 是类型的一部分，用来表示 begin 是一个指针类型，而不是说我们要将某个值赋给 *begin。</p><p>当你调用函数并传递参数时，例如 sum_arr(cookies, cookies + ArSize)，你传递的是实际的指针（即数组名 cookies 被自动转换为首元素的地址）。因此，在函数内部，begin 接收的是这个地址，而不是解引用后的值。</p><p>为了更清晰地理解这一点，我们可以考虑以下几点：</p><p>参数声明：当我们在函数定义中写 const int * begin 时，我们是在声明 begin 是一个指向常量整数的指针。这并不意味着我们将要直接操作 *begin；相反，它说明了我们将通过 begin 来间接访问数据。 参数传递：当我们调用 sum_arr(cookies, ...) 时，cookies 自动转换为指向其第一个元素的指针，并被赋值给 begin。这意味着 begin = &amp;cookies[0] 或者简单地说 begin = cookies，因为数组名可以隐式转换为指向其第一个元素的指针。 标准的理解：根据 C++ 标准，当你传递一个数组给函数时，实际上是在传递一个指向数组第一个元素的指针。而指针本身是一个存储内存地址的变量，它可以被复制和传递。这就是为什么我们声明的是 begin 而不是 *begin，因为我们需要传递的是地址，而不是该地址所指向的值。 解引用操作：*begin 是对 begin 指针进行解引用的操作，它返回指针所指向位置的值。在函数内部，我们使用 *begin 来读取或修改指针指向的数据，但这是在函数内部的操作，与参数传递无关。 总结<br> begin = cookies 是符合C++语言标准的行为，因为我们在传递的是指针，也就是地址，而不是指针所指向的值。声明的是 begin，因为它是我们用来接收传入地址的指针变量，而 *begin 只是我们在函数内部用来访问指针所指向的数据的方式。</p>',14)]))}const g=a(t,[["render",o]]);export{b as __pageData,g as default};

import{_ as s,c as a,o as n,ae as l}from"./chunks/framework.eveauE4a.js";const c=JSON.parse('{"title":"C++/WinRT 原理及实践 —— WinUI3 的页面加载事件解析、以WPF为源、C#/cppwinRT为例","description":"","frontmatter":{},"headers":[],"relativePath":"WinUI3/Loaded.md","filePath":"WinUI3/Loaded.md"}'),e={name:"WinUI3/Loaded.md"};function t(d,i,p,h,o,r){return n(),a("div",null,i[0]||(i[0]=[l(`<h1 id="c-winrt-原理及实践-——-winui3-的页面加载事件解析、以wpf为源、c-cppwinrt为例" tabindex="-1">C++/WinRT 原理及实践 —— WinUI3 的页面加载事件解析、以WPF为源、C#/cppwinRT为例 <a class="header-anchor" href="#c-winrt-原理及实践-——-winui3-的页面加载事件解析、以wpf为源、c-cppwinrt为例" aria-label="Permalink to &quot;C++/WinRT 原理及实践 —— WinUI3 的页面加载事件解析、以WPF为源、C#/cppwinRT为例&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>如果你对 WPF 框架熟悉，那么在 WinUI 3 中，你同样可以直接对页面或控件注册 Loaded 事件，而且语法更清晰。你仍然需要 Loaded 事件来执行“页面加载完成后”的逻辑 —— 它没有被废弃，只是写法变了。本篇将以最详细的解释为你疏清相关知识。</p><p>本节涉及到的概念有：</p><ul><li>事件注册</li><li>事件处理</li><li>XAML 根元素语法</li><li>C++ 回调</li><li>C++/WinRT 语法</li><li>C++ 成员函数指针</li></ul><h2 id="回顾" tabindex="-1">回顾 <a class="header-anchor" href="#回顾" aria-label="Permalink to &quot;回顾&quot;">​</a></h2><p>让我们先看看大多数熟悉的 WPF 为了实现页面加载后的逻辑是如何实现的。 我们使用的是事件注册语法：</p><h3 id="两种标准的-wpf-c-xaml-中的-loaded-事件写法" tabindex="-1">两种标准的 WPF（C#/XAML）中的 Loaded 事件写法 <a class="header-anchor" href="#两种标准的-wpf-c-xaml-中的-loaded-事件写法" aria-label="Permalink to &quot;两种标准的 WPF（C#/XAML）中的 Loaded 事件写法&quot;">​</a></h3><h4 id="在-wpf-里-你可以直接在-xaml-页面的根元素-如-window-或-page-类型-上写-这就可以了-相当于在-xaml-页面里注册了" tabindex="-1">在 WPF 里，你可以直接在 XAML 页面的根元素（如 Window 或 Page 类型）上写，这就可以了，相当于在 xaml 页面里注册了： <a class="header-anchor" href="#在-wpf-里-你可以直接在-xaml-页面的根元素-如-window-或-page-类型-上写-这就可以了-相当于在-xaml-页面里注册了" aria-label="Permalink to &quot;在 WPF 里，你可以直接在 XAML 页面的根元素（如 Window 或 Page 类型）上写，这就可以了，相当于在 xaml 页面里注册了：&quot;">​</a></h4><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Mainwindow.xaml</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> x:Class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Demo.MainWindow&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Window_Loaded&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; 这里需要你自定义</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 你的页面内容 Your page content --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>然后在 C# 代码里直接补充实现自动生成的事件处理函数：</p><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MainWindow.xaml.cs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window_Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 页面加载完成后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="我们同样还有另外的方法——也经常使用事件订阅语法-用来简便的注册和使用" tabindex="-1">我们同样还有另外的方法——也经常使用<strong>事件订阅</strong>语法 用来简便的注册和使用： <a class="header-anchor" href="#我们同样还有另外的方法——也经常使用事件订阅语法-用来简便的注册和使用" aria-label="Permalink to &quot;我们同样还有另外的方法——也经常使用**事件订阅**语法 用来简便的注册和使用：&quot;">​</a></h4><p>我们在对应的窗口类的构造函数里，用 cs 独有的<code>+=</code>（事件注册操作符）来添加事件处理程序，这也是标准的写法！当然你大可不遵守。 意思是把这个方法添加到这个事件的监听列表中。表示：当 Loaded 事件发生时，调用后面的方法。</p><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MainWindow.xaml.cs 的构造函数或其他初始化方法中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    InitializeComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用 += 简便地注册事件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //将 Window_Loaded 方法注册为 Loaded 事件的处理程序。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Window_Loaded;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 和前面所写的一致</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window_Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">object</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 页面加载完成后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="当然还有更简便的使用匿名方法-没有函数名字的方法-、-以-lambda-表达式注册" tabindex="-1">当然还有更简便的使用匿名方法（没有函数名字的方法）、 以 lambda 表达式注册： <a class="header-anchor" href="#当然还有更简便的使用匿名方法-没有函数名字的方法-、-以-lambda-表达式注册" aria-label="Permalink to &quot;当然还有更简便的使用匿名方法（没有函数名字的方法）、 以 lambda 表达式注册：&quot;">​</a></h4><div class="language-cs vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cs</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.Loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 直接写加载完成后的逻辑，适用于简单的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MessageBox.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;窗口已加载！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>我们也再仔细回顾一下这个 C# 语法方便初学者理解：</p><ul><li>()内代表要传给后面方法的参数列表。在这里事件处理函数的两个参数：</li><li>sender：表示是哪个对象触发了这个事件（比如是哪个窗口）。</li><li>e：是事件的参数，包含事件相关的额外信息（比如鼠标点击位置、键盘按键等）。</li><li>参数的具体类型是编译器自动推断</li></ul><h4 id="到底是什么" tabindex="-1">=&gt; 到底是什么？ <a class="header-anchor" href="#到底是什么" aria-label="Permalink to &quot;=&gt; 到底是什么？&quot;">​</a></h4><ul><li>符号读作 “goes to” 或 “yields to”。</li><li>它的作用是：把左边的参数，连接到右边的代码块或表达式。</li><li>类似于说：“用 (sender, e) 作为输入，执行 =&gt; 后面的大括号里的代码”。</li></ul><p>说的很详细了，不再过多解释。</p><h2 id="在-winui3-里什么发生了变化" tabindex="-1">在 WinUI3 里什么发生了变化 <a class="header-anchor" href="#在-winui3-里什么发生了变化" aria-label="Permalink to &quot;在 WinUI3 里什么发生了变化&quot;">​</a></h2><p>在 WinUI 3 C++/WinRT 框架中，Loaded 事件是 FrameworkElement 的成员。<br> 在 WPF（.NET 框架，C#/XAML）中，Window 和 Page 都继承自 FrameworkElement，而 FrameworkElement 有 Loaded 事件。所以你可以直接在 XAML 根元素这样写： 在 WinUI 3（无论 C# 还是 C++/WinRT），Window 和 Page 的继承体系发生了变化：（这点很坑）</p><ul><li>Window 类不再继承自 FrameworkElement，而是直接继承自 IInspectable。</li><li>Window 类里没有 Loaded 事件。</li><li>Page 在 WinUI 3 里虽然继承自 FrameworkElement，但有些事件的实现和 WPF 不完全一致。</li></ul><p>而只有属于 FrameworkElement 及其子类（如 Grid、StackPanel、Button 等）才有 Loaded 事件。你直接从主窗口使用该函数是会报错类中没有此成员函数的。</p><p>更清晰地来说，在 WinUI 3 的类型层次结构中，Window 直接继承自 IInspectable 属于 <a href="https://learn.microsoft.com/zh-cn/uwp/api/windows.ui.xaml.window?view=winrt-26100" target="_blank" rel="noreferrer">Microsoft.UI.Xaml</a> 命名空间，但它没有 Loaded 事件。FrameworkElement 则直接继承自 <a href="https://learn.microsoft.com/zh-cn/uwp/api/windows.ui.xaml.uielement?view=winrt-26100" target="_blank" rel="noreferrer">UIElement</a>。</p><h3 id="winui-3-中的-loaded-事件写法" tabindex="-1">WinUI 3 中的 Loaded 事件写法 <a class="header-anchor" href="#winui-3-中的-loaded-事件写法" aria-label="Permalink to &quot;WinUI 3 中的 Loaded 事件写法&quot;">​</a></h3><p>在 WinUI 3 里，Window 没有 Loaded 事件，Page 有，但仍然具有偶发的兼容性问题。具体来说在复杂的导航场景下，有些内容可能会被重新加载，导致 Loaded 事件可能会触发多次。生命周期和异步加载都有可能会影响 Loaded 事件的触发。所以需要仔细地控制页面的加载逻辑。</p><p>推荐在 xaml 页面的某个控件（如 LayoutGrid）上绑定 Loaded 事件：</p><div class="language-XML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">XML</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MainWindow.xaml</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    x:Class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Demo.MainWindow&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    xmlns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    xmlns:x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Grid</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;RootGrid_Loaded&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        &lt;!-- ... --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>C# 的 cs 页面代码同上，不再展出。</li><li>重点讲 C++/WinRT</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// MainWindow.xaml.cpp</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RootGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::OnRootGridLoaded });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnRootGridLoaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Windows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Foundation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInspectable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Xaml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 页面加载完成后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="cpp-winrt-语法讲解" tabindex="-1">cpp/winrt 语法讲解： <a class="header-anchor" href="#cpp-winrt-语法讲解" aria-label="Permalink to &quot;cpp/winrt 语法讲解：&quot;">​</a></h3><h5 id="_1-rootgrid" tabindex="-1">1.<code>RootGrid()</code> <a class="header-anchor" href="#_1-rootgrid" aria-label="Permalink to &quot;1.\`RootGrid()\`&quot;">​</a></h5><ul><li>这是 <code>C++/WinRT</code> 自动生成的<strong>属性访问器</strong>函数。</li><li>在 XAML 里 <code>&lt;Grid x:Name=&quot;RootGrid&quot;/&gt;</code>，编译后会自动生成一个名为 RootGrid() 的成员函数，返回这个控件对应 x:Name 的实例。</li><li>用法类似 C# 的 RootGrid 属性，但 C++/WinRT 里是函数调用（带括号）。</li></ul><h5 id="_2-loaded" tabindex="-1">2.<code>.Loaded(...)</code> <a class="header-anchor" href="#_2-loaded" aria-label="Permalink to &quot;2.\`.Loaded(...)\`&quot;">​</a></h5><ul><li>Loaded 是 FrameworkElement 的一个事件，表示控件已经加载到可视树。</li><li>这里的 .Loaded(...) 是给这个事件注册一个处理函数（事件监听器）。</li></ul><h5 id="_3-this-mainwindow-onrootgridloaded" tabindex="-1">3.<code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> <a class="header-anchor" href="#_3-this-mainwindow-onrootgridloaded" aria-label="Permalink to &quot;3.\`{ this, &amp;MainWindow::OnRootGridLoaded }\`&quot;">​</a></h5><ul><li>这是 C++/WinRT <strong>事件注册</strong>的标准写法，叫“<strong>委托</strong>”或“<strong>事件回调</strong>”。 <code>{ this, &amp;MainWindow::OnRootGridLoaded } </code>表示用当前对象（<code>this</code>）的成员函数 <code>OnRootGridLoaded()</code> 作为事件处理器。</li><li>看到&amp;别急着认为是引用类型，这里是个大学问！ <ul><li>此处代表了取地址动作，那学过cpp的都知道函数名字不就相当于地址（见 C++ primer plus 7.10.1节 P199），话说再取地址是什么了。NONONO。</li><li>对于非成员的函数（也就是不属于任何类的），函数名确实可以在很多情况下隐式转换为函数指针，此处不再举例。</li><li>对于成员函数来说，不用害怕，略有不同： <ul><li>当你处理的是类的成员函数时，情况变得更加复杂。因为成员函数的第一个<strong>隐含参数</strong>是<code>this</code>指针。这意味着成员函数指针不仅仅是简单的函数地址，它还需要知道它属于哪个对象实例。</li><li>当你写<code>&amp;MainWindow::OnRootGridLoaded</code>时，你实际上是显式地在获取该成员函数的指针，这个指针包含了如何调用该成员函数的信息（包括如何找到正确的对象实例）。因此，在这种情况下，使用&amp;是必要的语法要求，以明确表达你正在获取成员函数的地址。</li><li>实际上，你可以选择省略这个<code>&amp;</code>。如果你不加<code>&amp;</code>，MSVC 编译器也会自动推导出。 C++ 允许<strong>在需要函数指针的地方</strong>，<strong>隐式</strong>地将成员函数名转换为函数指针。但是为了可读性和避免使用模板时可能造成的错误，最好记得加上。</li><li>我们再回忆成员函数概念，以解释清楚。作为成员函数，那么必须要绑定到一个具体的对象上才能被调用</li><li>那函数名究竟是什么：func 的名字相当于一个特殊的左值（Ivalue），代表函数本身，但它不是指针类型。函数名会“隐式转换”为函数指针当编译器看到你把函数名用在需要函数指针的地方，它会自动帮你加上 <code>&amp;</code>。即：<strong>函数到函数指针的隐式转换</strong>（function-to-pointer conversion）。</li><li>所以，如果你随意一个地方直接写 <code>MainWindow::OnRootGridLoaded</code> 其实是不行的，因为它本身不是一个左值，而是一个名字或者说成员函数标识符。必须用 <code>&amp;</code> 显式获取它的“成员函数指针”。那为什么我们在这里可以省略，因为因为 <code>C++/WinRT</code> 的 <code>Loaded</code> 事件接受的是一个<strong>可调用对象</strong>（Callable）。当编译器看到 MainWindow::OnRootGridLoaded 被用在需要“函数指针”的上下文中，于是自动把它加上了<code>&amp;</code>。多亏隐式转换！</li></ul></li></ul></li><li>这种写法本质上是把<strong>成员函数指针</strong>和<strong>对象指针</strong>一起传递，<code>C++/WinRT</code> 框架会自动帮你在事件发生时调用这个成员函数。</li></ul><h4 id="事件注册语法" tabindex="-1">事件注册语法！ <a class="header-anchor" href="#事件注册语法" aria-label="Permalink to &quot;事件注册语法！&quot;">​</a></h4><ul><li>我们用花括号{}来注册事件，写在参数列表的<code>{}</code>里。</li><li><code>C++/WinRT</code> 事件注册需要一个“<strong>委托对象</strong>”，即谁来处理事件、用哪个成员函数。</li><li><code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> 是 <code>C++/WinRT</code> 的语法糖，等价于 C# 的 += 事件注册。</li><li>这样写可以让框架知道：当事件发生时，调用 this（当前窗口对象）的 <code>OnRootGridLoaded</code> 成员函数。</li></ul><h4 id="相信你看完还是一头雾水-这贵物东西究竟是个啥啊" tabindex="-1">相信你看完还是一头雾水！这贵物东西究竟是个啥啊！ <a class="header-anchor" href="#相信你看完还是一头雾水-这贵物东西究竟是个啥啊" aria-label="Permalink to &quot;相信你看完还是一头雾水！这贵物东西究竟是个啥啊！&quot;">​</a></h4><p><code>C++/WinRT</code> <strong>事件监听器</strong>（比如 Loaded）为什么在参数列表里要用大括号 { this, &amp;MainWindow::OnRootGridLoaded }，而不是像 C# 那样直接写方法名或者用 +=？</p><p>再展开来讲，里面有关的众多绕耳名词，我们再来整理整理：</p><ul><li><p>记住<code>.Loaded()</code>就属于<strong>事件监听器</strong>，（）内就是 <strong>事件注册</strong> 函数，使用<strong>注册监听器</strong>语法，同时也是一个<strong>事件</strong>，需要传递一个<strong>委托对象</strong>（delegate）。不要纠结它的各种名字，越记越混。记住它不是一个简单的函数。</p></li><li><p>{}这种写法叫委托构造，会自动生成一个事件处理对象 也就是用来处理这个事件的对象。</p></li><li><p>既然是对象，它就保存了两个信息：</p><ul><li>this：当前类的实例指针（告诉框架事件发生时要调用哪个对象的方法）</li><li>&amp;MainWindow::OnRootGridLoaded：成员函数指针（告诉框架具体调用哪个成员函数）</li></ul></li><li><p>作用：在这个事件函数发生时（也就是该绑定的界面元素被加载完成后）执行注册的函数，winRT会在此时帮你自动调用（依赖消息循环）</p></li><li><p>你写他.Loaded()，就是调用Loaded事件的<code>add</code>方法，将你的<code>回调</code>注册进去，这个回调是什么意思——</p></li><li><p>虽然我们不能直接写一个函数/函数名在里面，但是我们也还可以用 lambda 表达式类似 cs 的注册方式。</p><ul><li>它也支持 lambda 类型语法直接注册事件：</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   RootGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([](</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这里写要执行的内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>但是呢，我们使用 <code>{ this, &amp;MainWindow::OnRootGridLoaded }</code>是最常见和推荐的注册方式！</li></ul></li></ul><h2 id="回调" tabindex="-1">回调 <a class="header-anchor" href="#回调" aria-label="Permalink to &quot;回调&quot;">​</a></h2><h4 id="我们刚才不停地提到了事件回调-回调在-cpp-里是一个很有深度的概念" tabindex="-1">我们刚才不停地提到了事件回调，回调在 cpp 里是一个很有深度的概念： <a class="header-anchor" href="#我们刚才不停地提到了事件回调-回调在-cpp-里是一个很有深度的概念" aria-label="Permalink to &quot;我们刚才不停地提到了事件回调，回调在 cpp 里是一个很有深度的概念：&quot;">​</a></h4><p>其实我们一直在讲的就是<strong>事件回调</strong>（Event Callback）的典型用法（统称<strong>回调</strong>）。 回调 = 把函数作为事件注册出去，等事件发生时系统自动调用它。</p><p><code>{ this, &amp;MainWindow::OnRootGridLoaded }</code>这就是在注册一个回调函数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>    你写的代码：</span></span>
<span class="line"><span>    RootGrid().Loaded({ this, &amp;MainWindow::OnRootGridLoaded });</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    你告诉 XAML 系统：</span></span>
<span class="line"><span>    “当 RootGrid 加载完成时，请调用 MainWindow 的 OnRootGridLoaded 函数”</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    XAML 系统记住了这个“请求”（注册了回调）</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    运行时：RootGrid 真的加载完成了！</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    系统回头调用你提供的函数：</span></span>
<span class="line"><span>    this-&gt;OnRootGridLoaded(sender, e);</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>    你的代码执行：</span></span>
<span class="line"><span>    // 页面加载完成后的逻辑</span></span></code></pre></div><h5 id="这里也有一些-c-winrt-中的语法细节" tabindex="-1">这里也有一些 C++/WinRT 中的语法细节 <a class="header-anchor" href="#这里也有一些-c-winrt-中的语法细节" aria-label="Permalink to &quot;这里也有一些 C++/WinRT 中的语法细节&quot;">​</a></h5><p><code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> 是 <code>C++/WinRT</code> 的 事件处理程序语法，它等价于“绑定一个成员函数作为事件处理器”。底层使用了 <code>winrt::auto_revoke</code> 和<strong>委托</strong>（delegate）机制，确保对象销毁时自动取消注册，防止崩溃。我们可能以后会继续来解析。 值得一提的是这种方法非常利好于性能，因为回调的核心是在于提前告诉框架在哪一步要做什么。我们就不需要时时刻刻循环监听页面的变化进行处理，到达了我们已经设定的目标状态，winRT 就会来调用。 因为系统在事件发生时“回头调用”它 → 所以叫“回调”。</p><h4 id="事件处理函数" tabindex="-1">事件处理函数 <a class="header-anchor" href="#事件处理函数" aria-label="Permalink to &quot;事件处理函数&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OnRootGridLoaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Windows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Foundation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInspectable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">winrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Microsoft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Xaml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h5 id="winrt-windows-foundation-iinspectable-const-sender" tabindex="-1"><code>winrt::Windows::Foundation::IInspectable const&amp; sender</code> <a class="header-anchor" href="#winrt-windows-foundation-iinspectable-const-sender" aria-label="Permalink to &quot;\`winrt::Windows::Foundation::IInspectable const&amp; sender\`&quot;">​</a></h5><ul><li>sender：事件的发送者，即哪个控件触发了这个事件。</li><li>类型是 <code>IInspectable</code> <a href="https://learn.microsoft.com/en-us/windows/win32/api/inspectable/nn-inspectable-iinspectable" target="_blank" rel="noreferrer">MSLearn链接</a> <a href="./.html">讲解链接施工中</a>，这是 WinRT 所有对象的基类，类似 C# 里的 object。</li><li>你还可以使常用的 sender.as&lt;<code>Grid</code>&gt;() 之类的方法把它转换成具体控件类型，当然也可以不转换。 <ul><li><code>sender</code>：事件的发送者，基类型为 <code>IInspectable</code>。</li><li>.as&lt;<code>T</code>&gt;()：将 sender 转换为你需要的具体类型 T（如 Grid、Button 等）。</li><li>返回值是 T 目标类型的智能指针对象（如 winrt::Grid），可以直接访问控件的属性和方法。</li><li>在 C++/WinRT 中，事件处理函数的 sender 参数类型通常是 <code>winrt::Windows::Foundation::IInspectable</code>，这是 WinRT 所有对象的基类。</li><li>但实际触发事件的控件类型可能更具体，比如 Grid、Button 等。为了方便获取具体类型的对象，C++/WinRT 提供了 as&lt;<code>T</code>&gt;() 方法进行类型转换。</li><li>例如，你可以使用 sender.as&lt;<code>winrt::Microsoft::UI::Xaml::Controls::Grid</code>&gt;() 将 sender 转换为 Grid 类型，这样就可以访问 Grid 的特定属性和方法了。</li><li>注意事项： <ul><li>我们不要使用 <code>dynamic_cast</code> 或 <code>static_cast</code> 来转换 sender，因为 WinRT 使用了自己的类型系统和智能指针，其次它只适用于原生指针或引用也不支持这些 C++ 的 RTTI （运行时类型识别）特性，性能开销也很大。</li><li>sender 的类型是 <code>IInspectable</code>，它是 WinRT 所有对象的基类。本身不包含具体控件的属性和方法，你就访问不到。</li><li>如果 sender 实际不是你转换的类型，as&lt;<code>T</code>&gt;() 会抛出异常（<code>winrt::hresult_no_interface</code>）。</li><li>通常只有在你确定 sender 的实际类型时才使用 as&lt;<code>T</code>&gt;()。</li><li>这种写法类似于 C# 的 as 操作符，但 C++/WinRT 的 as&lt;<code>T</code>&gt;() 是强制转换，失败会抛异常。</li><li>你可以使用 try-catch 块来捕获异常，确保转换安全。但不能用模板函数来实现，因为 C++/WinRT 的 as&lt;<code>T</code>&gt;() 是编译时确定的类型转换且类型是确定的，当然你可以把它封装成一个函数来稍微简化使用。</li><li>底层调用 QueryInterface，只有在 sender 真正支持该类型时才会成功。</li></ul></li></ul></li></ul><h5 id="winrt-microsoft-ui-xaml-routedeventargs-const-e" tabindex="-1"><code>winrt::Microsoft::UI::Xaml::RoutedEventArgs const&amp; e</code> <a class="header-anchor" href="#winrt-microsoft-ui-xaml-routedeventargs-const-e" aria-label="Permalink to &quot;\`winrt::Microsoft::UI::Xaml::RoutedEventArgs const&amp; e\`&quot;">​</a></h5><ul><li>e：事件参数，包含事件相关的额外信息。</li><li>类型是 RoutedEventArgs，和 WPF 里的类似，表示“路由事件”的参数。</li><li>这里的命名空间是 Microsoft::UI::Xaml，因为 WinUI 3 的控件和事件都在这个命名空间下。</li></ul><h4 id="那问题来了-为什么有-windows-和-microsoft-两个命名空间" tabindex="-1">那问题来了：为什么有 Windows 和 Microsoft 两个命名空间？ <a class="header-anchor" href="#那问题来了-为什么有-windows-和-microsoft-两个命名空间" aria-label="Permalink to &quot;那问题来了：为什么有 Windows 和 Microsoft 两个命名空间？&quot;">​</a></h4><ul><li><p><code>winrt::Windows::Foundation::IInspectable：</code></p><ul><li>Windows::Foundation 是 WinRT 的基础命名空间，所有 WinRT 对象都继承自 IInspectable。</li><li>这是 WinRT 类型系统的根基，类似于 C# 的 object 或 C++ 的 void*，但有类型信息。</li></ul></li><li><p><code>winrt::Microsoft::UI::Xaml::RoutedEventArgs：</code></p><ul><li>Microsoft::UI::Xaml 是 WinUI 3 的控件和事件相关命名空间。</li><li>RoutedEventArgs 是所有路由事件的参数基类，包含事件路由相关信息。</li></ul></li></ul><h2 id="使用及用例" tabindex="-1">使用及用例 <a class="header-anchor" href="#使用及用例" aria-label="Permalink to &quot;使用及用例&quot;">​</a></h2><p>核心：手动在 XAML 里绑定 Loaded 事件，以及绑定必须要监听你的界面控件，属于在界面控件的代码。因为直接在界面根元素上绑定是没有的，会报错。</p><h3 id="什么时候-为什么要用-loaded-事件" tabindex="-1">什么时候，为什么要用 Loaded 事件？ <a class="header-anchor" href="#什么时候-为什么要用-loaded-事件" aria-label="Permalink to &quot;什么时候，为什么要用 Loaded 事件？&quot;">​</a></h3><p>Loaded 事件的典型应用场景包括：</p><ul><li><strong>初始化依赖于可视树的逻辑</strong>：有些操作（如获取控件的实际大小、布局信息、父子关系等）只有在控件真正加载到可视树后才能进行。</li><li><strong>动态数据绑定或界面刷新</strong>：在 Loaded 事件中加载数据、刷新界面，确保控件已准备好显示内容。</li><li><strong>动画、特效启动</strong>：页面或控件加载完成后启动动画，避免动画在控件未显示时提前执行。</li><li><strong>与外部资源交互</strong>：如页面加载后请求网络数据、初始化硬件资源等。</li><li><strong>只需执行一次的初始化逻辑</strong>：Loaded 事件只会在控件第一次加载到可视树时触发一次，适合做一次性的初始化。</li></ul><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li><strong>不要在 Loaded 事件中做耗时操作</strong>，否则会阻塞 UI 线程，导致界面卡顿。耗时操作应放到后台线程。</li><li><strong>Loaded 只触发一次</strong>，如果控件被移除再重新添加到可视树，会再次触发。</li><li><strong>Window 没有 Loaded 事件</strong>，只能在 Page 或 FrameworkElement（如 Grid、Panel、Button 等）上使用。</li></ul><h4 id="示例总结" tabindex="-1">示例总结 <a class="header-anchor" href="#示例总结" aria-label="Permalink to &quot;示例总结&quot;">​</a></h4><ul><li>WPF（C#）：Window/Page/控件都可以直接用 Loaded 事件。</li><li>WinUI 3（C#）：Page/控件可以用 Loaded，Window 不行。</li><li>WinUI 3（C++/WinRT）：只能在 FrameworkElement 及其子类控件上注册 Loaded 事件，推荐在主布局 Grid 上注册。</li></ul><h4 id="推荐实践" tabindex="-1">推荐实践 <a class="header-anchor" href="#推荐实践" aria-label="Permalink to &quot;推荐实践&quot;">​</a></h4><ul><li>在 XAML 主布局控件（如 <code>&lt;Grid x:Name=&quot;RootGrid&quot; Loaded=&quot;RootGrid_Loaded&quot;&gt;</code>）上注册相关 Loaded 事件。</li><li>在 C++/WinRT 代码中用 <code>{ this, &amp;MainWindow::OnRootGridLoaded }</code> 注册事件处理器。</li><li>只在 Loaded 事件中做与 UI 相关的初始化，避免阻塞 UI。</li></ul><p>下一章我们准备讲解 InitializeComponent 函数的原理和实现，敬请期待。</p>`,73)]))}const E=s(e,[["render",t]]);export{c as __pageData,E as default};

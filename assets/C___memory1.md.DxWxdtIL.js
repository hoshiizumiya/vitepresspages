import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.eveauE4a.js";const o=JSON.parse('{"title":"深度探索 C++ —— 移动语义","description":"","frontmatter":{},"headers":[],"relativePath":"C++/memory1.md","filePath":"C++/memory1.md"}'),h={name:"C++/memory1.md"};function l(p,s,e,k,d,r){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="深度探索-c-——-移动语义" tabindex="-1">深度探索 C++ —— 移动语义 <a class="header-anchor" href="#深度探索-c-——-移动语义" aria-label="Permalink to &quot;深度探索 C++ —— 移动语义&quot;">​</a></h1><h2 id="🧠-一、基本概念回顾-什么是-拷贝" tabindex="-1">🧠 一、基本概念回顾：什么是“拷贝”？ <a class="header-anchor" href="#🧠-一、基本概念回顾-什么是-拷贝" aria-label="Permalink to &quot;🧠 一、基本概念回顾：什么是“拷贝”？&quot;">​</a></h2><p>在 C++ 中，对象（比如 <code>std::vector</code>、<code>std::string</code>、自定义类）在赋值或传参时可能会发生 <strong>拷贝操作</strong>。 如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这里发生了拷贝</span></span></code></pre></div><p>上面这句 <code>v2 = v1</code> 就是拷贝。拷贝做了什么？</p><ul><li>分配一块新的内存空间；</li><li>把 <code>v1</code> 里面的所有元素复制到 <code>v2</code> 中；</li><li>如果 <code>v1</code> 很大，比如有几百万个元素，这会非常耗时。</li></ul><p>这就叫 <strong>深拷贝（deep copy）</strong>，因为它不是简单复制指针，而是复制整个数据内容。</p><h2 id="💰-二、深拷贝为什么-昂贵" tabindex="-1">💰 二、深拷贝为什么“昂贵”？ <a class="header-anchor" href="#💰-二、深拷贝为什么-昂贵" aria-label="Permalink to &quot;💰 二、深拷贝为什么“昂贵”？&quot;">​</a></h2><p>深拷贝之所以“昂贵”，是因为：</p><ul><li>内存分配和释放的开销；</li><li>数据复制的时间成本；</li><li>如果是嵌套结构（如 <code>vector&lt;vector&lt;int&gt;&gt;</code>），开销会指数级上升。</li></ul><h2 id="🚀-三、移动语义-move-semantics-是什么" tabindex="-1">🚀 三、移动语义（Move Semantics）是什么？ <a class="header-anchor" href="#🚀-三、移动语义-move-semantics-是什么" aria-label="Permalink to &quot;🚀 三、移动语义（Move Semantics）是什么？&quot;">​</a></h2><h3 id="_1-引入背景" tabindex="-1">1. 引入背景 <a class="header-anchor" href="#_1-引入背景" aria-label="Permalink to &quot;1. 引入背景&quot;">​</a></h3><p>C++11 引入了 <strong>移动语义（move semantics）</strong>，用来优化这种“昂贵的拷贝”。</p><p><strong>核心思想</strong>：如果一个对象是临时的、马上就要销毁了（比如函数返回的临时对象），那我们就不需要复制它，而是直接“偷走”它的资源！</p><h3 id="_2-举例说明" tabindex="-1">2. 举例说明 <a class="header-anchor" href="#_2-举例说明" aria-label="Permalink to &quot;2. 举例说明&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 返回的是一个临时对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这里不会拷贝，而是“移动”</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个例子中：</p><ul><li><code>createVector()</code> 返回的是一个临时对象（右值）；</li><li>在 C++11 之前，会调用拷贝构造函数；</li><li>在 C++11 之后，会调用 <strong>移动构造函数（move constructor）</strong>，直接“偷走”临时对象内部的资源（比如指针、内存地址），而不是复制数据。</li></ul><h2 id="❓-四、什么是移动构造函数-move-constructor" tabindex="-1">❓ 四、什么是移动构造函数（Move Constructor）？ <a class="header-anchor" href="#❓-四、什么是移动构造函数-move-constructor" aria-label="Permalink to &quot;❓ 四、什么是移动构造函数（Move Constructor）？&quot;">​</a></h2><h3 id="_1-定义" tabindex="-1">1. 定义 <a class="header-anchor" href="#_1-定义" aria-label="Permalink to &quot;1. 定义&quot;">​</a></h3><p>移动构造函数是一种特殊的构造函数，它的参数是右值引用（<code>T&amp;&amp;</code>）：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 移动构造函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> other</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 把 other 的资源“偷过来”</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 然后让 other 不再拥有这些资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="_2-它做了什么" tabindex="-1">2. 它做了什么？ <a class="header-anchor" href="#_2-它做了什么" aria-label="Permalink to &quot;2. 它做了什么？&quot;">​</a></h3><ul><li>不复制数据；</li><li>把“资源所有权”从一个对象转移到另一个对象；</li><li>原对象（被移动的）进入“有效但未定义状态”，不能再使用，但可以安全析构。</li></ul><hr><h2 id="❓-五、移动-vs-拷贝-区别总结" tabindex="-1">❓ 五、移动 vs 拷贝：区别总结 <a class="header-anchor" href="#❓-五、移动-vs-拷贝-区别总结" aria-label="Permalink to &quot;❓ 五、移动 vs 拷贝：区别总结&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>拷贝构造函数</th><th>移动构造函数</th></tr></thead><tbody><tr><td>参数类型</td><td><code>const T&amp;</code>（左值）</td><td><code>T&amp;&amp;</code>（右值）</td></tr><tr><td>是否复制数据</td><td>是</td><td>否（转移资源）</td></tr><tr><td>是否改变原对象</td><td>否</td><td>是（原对象资源被“偷走”）</td></tr><tr><td>性能</td><td>高开销（深拷贝）</td><td>极低开销（指针转移）</td></tr></tbody></table><hr><h2 id="❓六、什么是右值-什么是右值引用" tabindex="-1">❓六、什么是右值？什么是右值引用？ <a class="header-anchor" href="#❓六、什么是右值-什么是右值引用" aria-label="Permalink to &quot;❓六、什么是右值？什么是右值引用？&quot;">​</a></h2><h3 id="_1-左值-vs-右值" tabindex="-1">1. 左值 vs 右值 <a class="header-anchor" href="#_1-左值-vs-右值" aria-label="Permalink to &quot;1. 左值 vs 右值&quot;">​</a></h3><table tabindex="0"><thead><tr><th>类型</th><th>举例</th><th>是否可以取地址</th><th>是否可以修改</th></tr></thead><tbody><tr><td>左值</td><td><code>int a; a</code>, <code>x[i]</code></td><td>✅</td><td>✅</td></tr><tr><td>右值</td><td><code>5</code>, <code>a + b</code>, <code>f()</code></td><td>❌</td><td>❌</td></tr></tbody></table><ul><li>左值：有名字的对象，可以取地址；</li><li>右值：临时对象，没有名字，不能取地址；</li><li>移动语义只对右值生效。</li></ul><h3 id="_2-右值引用-t" tabindex="-1">2. 右值引用（T&amp;&amp;） <a class="header-anchor" href="#_2-右值引用-t" aria-label="Permalink to &quot;2. 右值引用（T&amp;&amp;）&quot;">​</a></h3><ul><li><code>T&amp;&amp;</code> 是一种引用类型，只能绑定到右值；</li><li>它允许我们对右值进行操作，比如“偷走”它的资源；</li><li>例如：<code>MyClass&amp;&amp; obj = MyClass();</code> 是合法的。</li></ul><hr><h2 id="🧪-七、移动构造函数-vs-拷贝构造函数" tabindex="-1">🧪 七、移动构造函数 vs 拷贝构造函数 <a class="header-anchor" href="#🧪-七、移动构造函数-vs-拷贝构造函数" aria-label="Permalink to &quot;🧪 七、移动构造函数 vs 拷贝构造函数&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vector&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 构造函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    MyVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;构造</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 拷贝构造函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    MyVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyVector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> other</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other.data;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;拷贝构造</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 移动构造函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    MyVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyVector</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> other</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(other.data);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 把 other 的资源“偷过来”</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;移动构造</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyVector</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MyVector </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 创建一个大对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MyVector a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 调用移动构造函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>输出可能是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>构造</span></span>
<span class="line"><span>移动构造</span></span></code></pre></div><p>说明没有调用拷贝构造函数，而是直接移动了资源，非常高效！</p><hr><h2 id="📌-八、什么时候用-const-什么时候用" tabindex="-1">📌 八、什么时候用 const&amp;，什么时候用 &amp;&amp;？ <a class="header-anchor" href="#📌-八、什么时候用-const-什么时候用" aria-label="Permalink to &quot;📌 八、什么时候用 const&amp;，什么时候用 &amp;&amp;？&quot;">​</a></h2><table tabindex="0"><thead><tr><th>场景</th><th>推荐写法</th><th>说明</th></tr></thead><tbody><tr><td>读取但不修改对象</td><td><code>const T&amp;</code></td><td>避免拷贝</td></tr><tr><td>接收临时对象并移动</td><td><code>T&amp;&amp;</code></td><td>移动语义，提升性能</td></tr><tr><td>接收左值并读取</td><td><code>const T&amp;</code></td><td>左值不能绑定到 <code>T&amp;&amp;</code></td></tr><tr><td>接收右值并移动</td><td><code>T&amp;&amp;</code></td><td>只能绑定到右值</td></tr></tbody></table><hr><h2 id="🧩-九、完美转发-perfect-forwarding-与-std-forward" tabindex="-1">🧩 九、完美转发（Perfect Forwarding）与 <code>std::forward</code> <a class="header-anchor" href="#🧩-九、完美转发-perfect-forwarding-与-std-forward" aria-label="Permalink to &quot;🧩 九、完美转发（Perfect Forwarding）与 \`std::forward\`&quot;">​</a></h2><p>在模板编程中，如果你希望一个函数参数既能接收左值又能接收右值，并且保持其左/右值属性，可以使用：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(arg));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 保持 arg 的左/右值属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这是高级用法，暂时不深入。</p><hr><h2 id="✅-十、总结-一句话总结" tabindex="-1">✅ 十、总结（一句话总结） <a class="header-anchor" href="#✅-十、总结-一句话总结" aria-label="Permalink to &quot;✅ 十、总结（一句话总结）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>概念</th><th>简单解释</th></tr></thead><tbody><tr><td>深拷贝</td><td>复制整个对象内容，很慢</td></tr><tr><td>移动语义</td><td>把资源从一个对象“偷”到另一个对象，很快</td></tr><tr><td>移动构造函数</td><td>专门用于右值的构造函数，避免拷贝</td></tr><tr><td>右值引用 <code>&amp;&amp;</code></td><td>只能绑定到临时对象（右值）</td></tr><tr><td>常量引用 <code>const&amp;</code></td><td>可以绑定到左值和右值，不能修改对象</td></tr></tbody></table><hr><p>如果你理解了这些内容，恭喜你已经掌握了 C++11 中最核心的性能优化机制之一：<strong>移动语义</strong>。</p>`,53)]))}const c=i(h,[["render",l]]);export{o as __pageData,c as default};

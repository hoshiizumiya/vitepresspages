import{_ as n,c as a,o as e,ae as t}from"./chunks/framework.eveauE4a.js";const k=JSON.parse('{"title":"WinUI 3 页面初始化之 InitializeComponent","description":"","frontmatter":{},"headers":[],"relativePath":"WinUI3/InitializeComponent.md","filePath":"WinUI3/InitializeComponent.md"}'),o={name:"WinUI3/InitializeComponent.md"};function s(l,i,p,r,d,h){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="winui-3-页面初始化之-initializecomponent" tabindex="-1">WinUI 3 页面初始化之 InitializeComponent <a class="header-anchor" href="#winui-3-页面初始化之-initializecomponent" aria-label="Permalink to &quot;WinUI 3 页面初始化之 InitializeComponent&quot;">​</a></h1><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>在 WinUI 3/C++/WinRT 项目中，<code>InitializeComponent()</code> 是一个重要的函数，用于加载 XAML 文件并初始化页面或控件。它通常在构造函数中调用，以确保页面的 UI 元素被正确创建和配置。</p><h2 id="_1-initializecomponent-的作用" tabindex="-1">1. <code>InitializeComponent()</code> 的作用 <a class="header-anchor" href="#_1-initializecomponent-的作用" aria-label="Permalink to &quot;1. \`InitializeComponent()\` 的作用&quot;">​</a></h2><p>在 WinUI 3/C++/WinRT 项目中，<code>InitializeComponent()</code> 通常只需要在构造函数里调用一次，用于加载 XAML 并初始化控件。</p><h3 id="initializecomponent-函数解析" tabindex="-1">InitializeComponent() 函数解析 <a class="header-anchor" href="#initializecomponent-函数解析" aria-label="Permalink to &quot;InitializeComponent() 函数解析&quot;">​</a></h3><p><code>InitializeComponent()</code> 是 WinUI 应用程序中的一个关键函数，用于初始化 XAML 界面组件。这个函数的主要作用包括：</p><h3 id="功能概述" tabindex="-1">功能概述 <a class="header-anchor" href="#功能概述" aria-label="Permalink to &quot;功能概述&quot;">​</a></h3><ol><li><p><strong>XAML 解析与加载</strong>：该函数负责解析和加载在 XAML 文件中定义的 UI 元素</p></li><li><p><strong>控件实例化</strong>：将 XAML 中声明的所有控件（按钮、文本框、列表等）实例化为实际的 C++ 对象</p></li><li><p><strong>建立事件连接</strong>：将 XAML 中定义的事件处理程序与 C++ 代码中的函数进行关联</p></li><li><p><strong>应用样式和资源</strong>：加载并应用在 XAML 中定义的样式、主题和资源</p></li></ol><h3 id="在代码中的位置和作用" tabindex="-1">在代码中的位置和作用 <a class="header-anchor" href="#在代码中的位置和作用" aria-label="Permalink to &quot;在代码中的位置和作用&quot;">​</a></h3><p>在你的 <code>MainWindow</code> 构造函数中，<code>InitializeComponent()</code> 是构造过程中的第一个调用：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MainWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    InitializeComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这保证了在进行任何其他操作前，UI 组件已经被正确初始化和准备就绪。在这个例子中，只有在调用 <code>InitializeComponent()</code> 之后，才能对 <code>sourceList()</code> 进行操作。</p><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p><code>InitializeComponent()</code> 函数通常是由 WinUI 项目系统自动生成的，不需要手动编写。它在幕后完成以下工作：</p><ul><li>将 XAML 标记转换为实际的 UI 元素</li><li>将这些元素添加到视觉树中</li><li>设置在 XAML 中定义的属性</li><li>连接事件处理程序</li></ul><p>如果不调用此函数，XAML 中定义的 UI 元素将不会被加载，应用程序的界面将为空白。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>InitializeComponent()</code> 是连接 XAML 声明式 UI 和 C++ 代码的桥梁，确保在应用程序启动时正确设置用户界面。它是 XAML 基础设施的核心部分，在所有 WinUI 窗口和页面的构造函数中都必须调用。</p><p>在 <code>Page_Loaded</code> 事件处理函数里再次调用 <code>InitializeComponent()</code> 是多余的，甚至可能导致异常或重复初始化。</p><p><strong>一般流程：</strong></p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserMainPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserMainPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    InitializeComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 只在这里调用一次</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 其他初始化逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserMainPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Page_Loaded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IInspectable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RoutedEventArgs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这里不需要 InitializeComponent()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 可以放置页面加载后的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>小结：</strong><br><code>InitializeComponent()</code> 只需在构造函数中调用一次，<code>Page_Loaded</code> 里不需要。</p><h2 id="_2-initializecomponent-的必要性" tabindex="-1">2. <code>InitializeComponent()</code> 的必要性 <a class="header-anchor" href="#_2-initializecomponent-的必要性" aria-label="Permalink to &quot;2. \`InitializeComponent()\` 的必要性&quot;">​</a></h2><h3 id="_1-构造函数里没写-initializecomponent-页面会隐式初始化吗" tabindex="-1">1. 构造函数里没写 <code>InitializeComponent()</code> 页面会隐式初始化吗？ <a class="header-anchor" href="#_1-构造函数里没写-initializecomponent-页面会隐式初始化吗" aria-label="Permalink to &quot;1. 构造函数里没写 \`InitializeComponent()\` 页面会隐式初始化吗？&quot;">​</a></h3><p><strong>不会隐式初始化。</strong><br> 在 C++/WinRT（WinUI 3）中，<code>InitializeComponent()</code> 必须<strong>手动调用</strong>，通常在页面类的构造函数里。<br> 如果你没调用，XAML 里的控件不会被实例化，成员变量（如 <code>Button</code>、<code>Frame</code> 等）也不会被绑定，访问这些控件会导致空指针异常。</p><blockquote><p>C# 里会自动生成并调用，但 C++/WinRT 需要你自己写！！</p></blockquote><h3 id="_2-initializecomponent-都做了什么" tabindex="-1">2. <code>InitializeComponent()</code> 都做了什么？ <a class="header-anchor" href="#_2-initializecomponent-都做了什么" aria-label="Permalink to &quot;2. \`InitializeComponent()\` 都做了什么？&quot;">​</a></h3><ul><li>解析并加载对应的 XAML 文件（如 <code>UserMainPage.xaml</code>）。</li><li>创建并实例化 XAML 里声明的所有控件对象。</li><li>将 XAML 里 <code>x:Name</code> 标记的控件，绑定到 C++ 类的同名成员变量。</li><li>连接 XAML 里声明的事件（如 <code>Click=&quot;OnClick&quot;</code>）到 C++ 的事件处理函数。</li></ul><p><strong>简言之：它让你的 C++ 代码和 XAML UI 关联起来。</strong></p><h3 id="_3-页面加载顺序和函数执行流程" tabindex="-1">3. 页面加载顺序和函数执行流程 <a class="header-anchor" href="#_3-页面加载顺序和函数执行流程" aria-label="Permalink to &quot;3. 页面加载顺序和函数执行流程&quot;">​</a></h3><p>以 <code>UserMainPage</code> 为例，典型流程如下：</p><ol><li><p><strong>构造函数</strong></p><ul><li>你手动调用 <code>InitializeComponent()</code>，XAML 被加载，控件被实例化。</li><li>可以在这里做成员变量初始化、注册事件等。</li></ul></li><li><p><strong>Loaded 事件</strong></p><ul><li>页面元素已加载到可视树，控件都可用。</li><li>适合做依赖控件的初始化、数据绑定等。</li></ul></li><li><p><strong>OnNavigatedTo（如果有）</strong></p><ul><li>页面被导航到时触发，适合处理导航参数。</li></ul></li></ol><p><strong>常见顺序：</strong></p><ul><li>构造函数 → InitializeComponent → Loaded 事件 → OnNavigatedTo</li></ul><h3 id="_4-小结与建议" tabindex="-1">4. 小结与建议 <a class="header-anchor" href="#_4-小结与建议" aria-label="Permalink to &quot;4. 小结与建议&quot;">​</a></h3><ul><li>C++/WinRT 必须手动调用 <code>InitializeComponent()</code>，否则 XAML 不会生效。</li><li>它负责加载 XAML、实例化控件、事件绑定等。</li><li>推荐在构造函数里第一行调用。</li><li>页面加载顺序：构造函数 → InitializeComponent → Loaded → OnNavigatedTo</li></ul><h2 id="_3-c-winrt-xaml-控件访问与-initializecomponent-详解" tabindex="-1">3.C++/WinRT XAML 控件访问与 InitializeComponent 详解 <a class="header-anchor" href="#_3-c-winrt-xaml-控件访问与-initializecomponent-详解" aria-label="Permalink to &quot;3.C++/WinRT XAML 控件访问与 InitializeComponent 详解&quot;">​</a></h2><h3 id="_1-c-winrt-下-xaml-控件的生成与访问机制" tabindex="-1">1. C++/WinRT 下 XAML 控件的生成与访问机制 <a class="header-anchor" href="#_1-c-winrt-下-xaml-控件的生成与访问机制" aria-label="Permalink to &quot;1. C++/WinRT 下 XAML 控件的生成与访问机制&quot;">​</a></h3><ul><li><strong><code>InitializeComponent()</code> 的作用</strong><br> 它负责加载 XAML 文件，实例化界面控件，并把带有 <code>x:Name</code> 的控件和 C++ 类的同名方法（通常是自动生成的 getter）关联起来。</li><li><strong>如果不调用 <code>InitializeComponent()</code></strong><br> XAML 文件不会被加载，控件不会被实例化。你访问 <code>x:Name</code> 相关的控件 getter 时，返回的是未初始化的对象（通常为 <code>nullptr</code>），访问其成员会崩溃。 如图所示：</li><li><img src="https://cdn.jsdelivr.net/gh/hoshiizumiya/images/withoutinitializeComponetresult.png" alt="InitializeComponent"></li></ul><h3 id="_2-为什么有时-没写-initializecomponent-也能访问控件" tabindex="-1">2. 为什么有时“没写 InitializeComponent() 也能访问控件”？ <a class="header-anchor" href="#_2-为什么有时-没写-initializecomponent-也能访问控件" aria-label="Permalink to &quot;2. 为什么有时“没写 InitializeComponent() 也能访问控件”？&quot;">​</a></h3><ul><li><strong>可能的原因：</strong><ol><li><strong>构造函数里其实已经自动生成并调用了 <code>InitializeComponent()</code></strong><br> 有些模板或代码生成工具会自动加上这行代码。</li><li><strong>你看到的例子其实并没有真正访问控件属性或方法</strong><br> 只是声明了 getter，但没有实际用到控件。</li><li><strong>C# 项目</strong><br> C# 项目会自动在构造函数里调用 <code>InitializeComponent()</code>，但 C++/WinRT 不会自动加。</li></ol></li></ul><h3 id="_3-结论" tabindex="-1">3. 结论 <a class="header-anchor" href="#_3-结论" aria-label="Permalink to &quot;3. 结论&quot;">​</a></h3><ul><li><strong>C++/WinRT 项目中，必须手动调用 <code>InitializeComponent()</code>，否则 XAML 控件不会被实例化。</strong></li><li>你能通过 <code>x:Name()</code> 访问控件，是因为 <code>InitializeComponent()</code> 已经把它们和 C++ 代码关联起来。</li><li>如果没调用，getter 返回的就是空对象，访问会出错。</li></ul><h4 id="小贴士" tabindex="-1">小贴士 <a class="header-anchor" href="#小贴士" aria-label="Permalink to &quot;小贴士&quot;">​</a></h4><p>你可以试着注释掉 <code>InitializeComponent()</code>，然后访问 <code>x:Name</code> 控件，调试时会发现控件是空的。</p>`,46)]))}const m=n(o,[["render",s]]);export{k as __pageData,m as default};
